# 一、进程与线程

## 1.1 进程的概念和特征

### 1.1.1 进程的概念

程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。

进程（Process）：是动态的，是程序的一次执行过程。同一个程序多次执行会对应多个进程

>动态性是进程最基本的特征
>
>异步性会导致并发程序执行结果的不确定性。

当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”—— PID（Process ID，进程ID）这些信息都被保存在一个数据结构PCB （Process Control Block）中，即进程控制块操作系统需要对各个并发运行的进程进行管理，**但凡管理时所需要的信息，都会被放在PCB中**

**PCB是进程存在的唯一标志**，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。其需要保存的信息大致分为

- 进程描述信息

  - 进程标识符PID
  - 用户标识符UID
- 进程控制和管理信息
  - CPU、磁盘、网络流量使用情况统计...
  - 进程当前状态:就绪态/阻塞态/运行态...


  - 资源分配清单
    
      - 正在使用哪些文件
      - 正在使用哪些内存区域
      - 正在使用哪些I/O设备
  - 处理机相关信息
    
      - 如PSW、PC等等各种寄存器的值（用于实现进程切换)

进程的组成

- PCB
- 程序段：程序的代码(指令序列)
- 数据段：运行过程中产生的各种数据

程序段、数据段、PCB三部分组成了**进程实体（进程映像）**

引入进程实体的概念后，可把进程定义为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

### 1.1.2 进程的特征

相比于程序，进程有以下特征：

- 动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的
- 并发性：内存中有多个进程实体，各进程可并发执行
- 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位
- 异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供"“进程同步机制"来解决异步问题
- 结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成

## 1.2 进程的状态与转化

进程的状态如下

- 进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化PCB
- 当进程创建完成后，便进入“就绪态”，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行
- 如果一个进程此时在CPU上运行，那么这个进程处于“运行态”。CPU会执行该进程对应的程序（执行指令序列）
- 在进程运行的过程中，可能会请求等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的响应）。在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“阻塞态”当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行
- 一个进程可以执行exit 系统调用，请求操作系统终止该进程。此时该进程会进入“终止态”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB。当终止进程的工作完成之后，这个进程就彻底消失了。

> 其中，运行态、就绪态和阻塞态是进程的三个基本状态

![进程状态的转换.png](https://upload-images.jianshu.io/upload_images/26868451-f017eef5880440d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 单CPU情况下，同一时刻只会有一个进程处于运行态，多核CPU情况下，可能有多个进程处于运行态

## 1.3 进程组织

在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。

进程的组织方式分为两种

- 链接方式
  - 按照进程状态将PCB分为多个队列
  - 操作系统持有指向各个队列的指针

![链接方式.png](https://upload-images.jianshu.io/upload_images/26868451-aec770501b204d52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 索引方式
  - 根据进程状态的不同，建立几张索引表
  - 操作系统持有指向各个索引表的指针

![索引方式.png](https://upload-images.jianshu.io/upload_images/26868451-d0407e6907d7c302.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 1.4 进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、**实现进程状态转换**等功能。

实现进程控制用“原语”实现。原语是一种特殊的程序，它的执行具有原子性。也就是说，这段程序的运行必须一气呵成，不可中断

### 1.4.1 进程的创建

- 创建原语
  - 申请空白PCB
  - 为新进程分配所需资源
  - 初始化PCB
  - 将PCB插入就绪队列
- 引起进程创建的事件
  - 用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程
  - 作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程
  - 提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求
  - 应用请求：由用户进程主动请求创建一个子进程

### 1.4.2 进程的终止

- 撤销原语
  - 从PCB集合中找到终止进程的PCB
  - 若进程正在运行，立即剥夺CPu，将CPU分配给其他进程
  - 终止其所有子进程
  - 将该进程拥有的所有资源归还给父进程或操作系统
  - 删除PCB
- 引起进程终止的事件
  - 正常结束，如进程自己请求终止(exit系统调用)
  - 异常结束，如整数除以o、非法使用特权指令，然后被操作系统强行杀掉
  - 外界干预，如Ctrl+Alt+delete，用户选择杀掉进程

### 1.4.3 进程的阻塞和唤醒

- 进程的阻塞
  - 阻塞原语
    - 找到要阻塞的进程对应的PCB
    - 保护进程运行现场，将PCB状态信息设置为"阻塞态"，暂时停止进程运行
    - 将PCB插入相应事件的等待队列
  - 引起进程阻塞的事件
    - 需要等待系统分配某种资源
    - 需要等待相互合作的其他进程完成工作
- 进程的唤醒
  - 唤醒原语
    - 在事件等待队列中找到PCB
    - 将PCB从等待队列移除，设置进程为就绪态
    - 将PCB插入就绪队列，等待被调度
  - 引起进程唤醒的事件——等待的事件发生

> 因何事阻塞，就应由何事唤醒，因此阻塞原语唤醒原语必须成对使用

### 1.4.4 进程切换

- 切换原语
  - 将运行环境信息存入PCB
  - PCB移入相应队列
  - 选择另一个进程执行，并更新其PCB
  - 根据PCB恢复新进程所需的运行环境
- 引起进程切换的事件
  - 当前进程时间片到
  - 有更高优先级的进程到达
  - 当前进程主动阻塞
  - 当前进程终止

## 1.5 进程的通信

进程通信就是指进程之间的信息交换。进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。

为了保证安全，一个进程不能直接访问另一个进程的地址空间。但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。

### 1.5.1 共享存储

基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式

基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。

> 两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）。操作系统只负责提供共享空间和同步互斥工具（如P、V操作）

### 1.5.2 消息传递

进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。

- 直接通信方式：消息直接挂到接收进程的消息缓冲队列上
- 间接通信方式：消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。[^Eg]

[^Eg]: 计网中的电子邮件系统

### 1.5.3 管道通信

“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区

1. 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。
2. 各进程要互斥地访问管道。
3. 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。
4. 如果没写满，就不允许读。如果没读空，就不允许写。
5. 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。

## 1.6 线程的概念和多线程模型

### 1.6.1 线程的基本概念

有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。

可以把线程理解为“轻量级进程”。线程是一个基本的CPU执行单元，也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。线程则作为处理机的分配单元。

> 传统进程机制中、进程是资源分配、调度的基本单位，引入线程后，进程是资源分配的基本单位，线程是调度的基本单位

### 1.6.2 线程的属性

- 线程几乎不拥有系统资源，每个线程都有一个线程ID、线程控制块(TCB)
- 不同线程可以执行相同的程序，同一个服务程序被不同的用户调用时，操作系统把他们创建不同的线程
- 同一进程的不同线程间共享进程的资源
- 线程是处理机调度的单位，多个线程可以并发执行。多CPU计算机中，各个线程可占用不同的CPU
- 一个线程被创建后，便开始了它的生命周期，直到终止。线程也有就绪、阻塞、运行三种基本状态


由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预，同一进程中的线程切换，不会引起进程切换，不同进程中的线程切换，会引起进程切换。切换同进程内的线程，系统开销很小，切换进程，系统开销较大

### 1.6.3 线程的实现方式

线程的实现方式可以分为用户级线程和内核级线程

#### 1.6.3.1 用户级线程

1. 用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）
2. 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。
3. 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。

#### 1.6.3.2 内核级线程

1. 内核级线程的管理工作由操作系统内核完成。
2. 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。
3. 操作系统会为每个内核级线程建立相应的TCB（Thread Control Block，线程控制块），通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。

缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

###  1.6.4 多线程模型

- 一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。

缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

- 多对一模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行

- 多对多模型：n 用户及线程映射到m 个内核级线程（n >= m）。每个用户进程对应m 个内核级线程。

克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

**操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。**

> 内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞