# 二、 处理机调度

## 2.1 调度的概念

### 2.1.1 调度的基本概念

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。

### 2.1.2 调度的层次

一个作业从提交开始直到完成，往往要经历以下三级调度

1. 高级调度（作业调度）。按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。
2. 中级调度（内存调度）。按照某种策略决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。
3. 低级调度（进程调度/处理机调度）。按照某种策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。

### 2.1.3 三级调度的联系

| 名称                 | 介绍                                                         | 调度发生在          | 发生频率 | 对进程状态的影响 |
| -------------------- | :----------------------------------------------------------- | ------------------- | -------- | ---------------- |
| 高级调度（作业调度） | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存→内存(面向作业) | 最低     | 无→创建态→就绪态 |
| 中级调度（内存调度） | 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存     | 外存→内存(面向进程) | 中等     | 挂起态→阻塞态    |
| 低级调度（进程调度） | 按照某种规则，从就绪队列中选择一个进程为其分配处理机         | 内存→CPU            | 最高     | 就绪态→运行态    |

## 2.2 调度的时机、切换和过程

### 2.2.1 进程调度的时机

需要进行进程调度与切换的情况

- 当前运行的进程主动放弃处理机
  - 进程正常终止
  - 运行过程中发生异常而终止
  - 进程主动请求阻塞（如等待I/O）
- 当前运行的进程被动放弃处理机
  - 分给进程的时间片用完
  - 有更紧急的事需要处理（如I/O中断）
  - 有更高优先级的进程进入就绪队列

不能进行进程调度与切换的情况

- 在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。
- 进程在操作系统内核程序临界区中。
- 在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）

### 2.2.2 进程调度方式

- 非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统
- 剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统

### 2.2.3 进程切换与过程

狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）

进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。

广义的进程调度包含了选择一个进程和进程切换两个步骤。

进程切换的过程主要完成了：
1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）

**进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。**

## 2.3 调度的基本准则

### 2.3.1 CPU利用率

CPU利用率：指CPU “忙碌”的时间占总时间的比例。
$$
\eta=\frac{t_1}{t_2}
$$

式中，t1为忙碌的时间，t2为总时间,η为利用率

> Eg：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒，再用打印机打印输出5秒，之后再执行5秒，才能结束。在此过程中，CPU利用率、打印机利用率分别是多少？
>
> CPU利用率=(5+5)/(5+5+5)= 66.66%
> 打印机利用率=5/15= 33.33%

### 2.3.2 系统吞吐量

系统吞吐量：单位时间内完成作业的数量，其等于总共完成了多少作业除以总共花了多少时间

> Eg：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？
>
> 10/100 = 0.1 道/秒

### 2.3.3 周转时间

周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。（周转时间= 作业完成时间– 作业提交时间）它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。

平均周转时间=各作业周转时间之和 \ 作业数

带权周转时间=作业周转时间 \ 作业实际运行的时 = (作业完成时间– 作业提交时间) \ 作业实际运行的时间

平均带权周转时间= 各作业带权周转时间之和 \作业数

### 2.3.4 等待时间

等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。

对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。

对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。

### 2.3.5 响应时间

响应时间，指从用户提交请求到首次产生响应所用的时间。

## 2.4 典型的调度算法

### 2.4.1 先来先服务(FCFS)调度算法

按照作业/进程到达的先后顺序进行服务，用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列，属于非抢占式的算法

优点：公平、算法实现简单，不会导致饥饿

缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利

> ![例题.png](https://upload-images.jianshu.io/upload_images/26868451-947fb7448e11f97f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>
> 周转时间= 完成时间- 到达时间P1=7-0=7；P2=11-2=9；P3=12-4=8；P4=16-5=11
> 带权周转时间= 周转时间/运行时间P1=7/7=1；P2=9/4=2.25；P3=8/1=8；P4=11/4=2.75
> 等待时间= 周转时间– 运行时间P1=7-7=0；P2=9-4=5；P3=8-1=7；P4=11-4=7
> 平均周转时间= (7+9+8+11)/4 = 8.75
> 平均带权周转时间= (1+2.25+8+2.75)/4 = 3.5
> 平均等待时间= (0+5+7+7)/4 = 4.75

### 2.4.2 短作业优先(SJF)

最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”SJF和SPF是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法（SRTN, Shortest Remaining Time Next）

优点：“最短的”平均等待时间、平均周转时间

缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先

> ![例题.png](https://upload-images.jianshu.io/upload_images/26868451-981a34d31d41ea26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>
> 周转时间= 完成时间- 到达时间P1=7-0=7；P3=8-4=4；P2=12-2=10；P4=16-5=11
> 带权周转时间= 周转时间/运行时间P1=7/7=1；P3=4/1=4；P2=10/4=2.5；P4=11/4=2.75
> 等待时间= 周转时间– 运行时间P1=7-7=0；P3=4-1=3；P2=10-4=6；P4=11-4=7
> 平均周转时间= (7+4+10+11)/4 = 8
> 平均带权周转时间= (1+4+2.5+2.75)/4 = 2.56
> 平均等待时间= (0+3+6+7)/4 = 4

最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度

> ![图片.png](https://upload-images.jianshu.io/upload_images/26868451-8a58d065fe799238.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>
> 周转时间= 完成时间- 到达时间P1=16-0=16；P2=7-2=5；P3=5-4=1；P4=11-5=6
> 带权周转时间= 周转时间/运行时间P1=16/7=2.28；P2=5/4=1.25；P3=1/1=1；P4=6/4=1.5
> 等待时间= 周转时间– 运行时间P1=16-7=9；P2=5-4=1；P3=1-1=0；P4=6-4=2
> 平均周转时间= (16+5+1+6)/4 = 7
> 平均带权周转时间= (2.28+1.25+1+1.5)/4 = 1.50
> 平均等待时间= (9+1+0+2)/4 = 3

### 2.4.3 高响应比优先(HRRN)算法

在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务即可用于作业调度，也可用于进程调度。非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比

响应比={等待时间+要求服务时间} \ {要求服务时间}

综合考虑了等待时间和运行时间（要求服务时间）等待时间相同时，要求服务时间短的优先（SJF 的优点）要求服务时间相同时，等待时间长的优先（FCFS 的优点）对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题

> ![图片.png](https://upload-images.jianshu.io/upload_images/26868451-c97d5d75149fa126.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>
> 0时刻：只有P1 到达就绪队列，P1上处理机
> 7时刻（P1主动放弃CPU）： 就绪队列中有P2 (响应比=(5+4)/4=2.25)、P3((3+1)/1=4)、P4((2+4)/4=1.5)，
> 8时刻（P3完成）： P2(2.5)、P4(1.75)
> 12时刻（P2完成）：就绪队列中只剩下P4

### 2.4.4 时间片轮转(RR)

按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）。若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到

优点：公平；响应快，适用于分时操作系统；不会导致饥饿

缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。

> ![图片.png](https://upload-images.jianshu.io/upload_images/26868451-45c4e3a99b764d28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>
> 时间片大小为2
>
> 0时刻（P1(5)）:0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片
> 2时刻（P2(4)→P1(3)）:2时刻P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。
> 此时P2排在队头，因此让P2上处理机。（注意： 2时刻，P1下处理机，同一时刻新进程P2到达，如果在题目中遇到这种情况，默认新到达的进程先进入就绪队列）
> 4时刻（P1(3)→P3(1)→P2(2)）:4时刻，P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾
> 5时刻（P3(1)→P2(2)→P4(6)）:5时刻，P4到达插到就绪队尾（注意：由于P1的时间片还没用完，因此暂时不调度。另外，此时P1处于运行态，并不在就绪队列中）
> 6时刻（P3(1)→P2(2)→P4(6)→P1(1)）：6时刻，P1时间片用完，下处理机，重新放回就绪队尾，发生调度
> 7时刻（P2(2)→P4(6)→P1(1)）：虽然P3的时间片没用完，但是由于P3只需运行1个单位的时间，运行完了会主动放弃处理机，因此也会发生调度。队头进程P2上处理机。
> 9时刻（P4(6)→P1(1)）：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机
> 11时刻（P1(1)→P4(4) ）：P4时间片用完，重新回到就绪队列。P1上处理机
> 12时刻（P4(4) ）：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机
> 14时刻（）：就绪队列为空，因此让P4接着运行一个时间片。
> 16时刻：所有进程运行结束

如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。

另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。

> 一般来说，设计时间片时要让切换进程的开销占比不超过1%

### 2.4.5 优先级调度算法

每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中。抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。

优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。

缺点：若源源不断地有高优先级进程到来，则可能导致饥饿

根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。

- 静态优先级：创建进程时确定，之后一直不变。
- 动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。

通常

- 系统进程优先级高于用户进程
- 前台进程优先级高于后台进程
- 操作系统更偏好I/O型进程（或称I/O繁忙型进程）

### 2.4.6 多级反馈队列调度算法

规则：

1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾
3. 只有第k 级队列为空时，才会为k+1 级队头的进程分配时间片

用于进程调度。抢占式的算法。在k 级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k 级队列队尾。

对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）

>  ![图片.png](https://upload-images.jianshu.io/upload_images/26868451-1f4d4d76cc1bbafb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>
>  设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
>
>  新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾
>
>  只有第k 级队列为空时，才会为k+1 级队头的进程分配时间片,被抢占处理机的进程重新放回原队列队尾