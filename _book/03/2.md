# 二、 虚拟内存管理

## 2.1 虚拟内存的基本概念

### 2.1.1 传统存储管理方式的特征

传统存储管理很多暂时用不到的数据也会长期占用内存，导致内存利用率不高，他们具有以下两个特征

- 一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：①作业很大时，不能全部装入内存，导致大作业无法运行；②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。
- 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

### 2.1.2 局部性原理

高速缓冲技术的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。快表机构就是将近期常访问的页表项副本放到更高速的联想寄存器中，其依赖的就是局部性原理

时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）

空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）

### 2.1.3 虚拟存储器的定义和特征

基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是**虚拟内存**。虚拟内存是操作系统虚拟性的一个体现，实际的物理内存大小没有变，只是在逻辑上进行了扩充。

虚拟内存有以下三个主要特征：

- 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
- 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
- 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

### 2.1.4 实现虚拟内存技术

虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在离散分配的内存管理方式基础上。

虚拟内存的实现有以下三种方式

- 请求分页存储管理
- 请求分段存储管理
- 请求段页式存储管理

在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。[^注1]若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。[^注3]

[^注1]: 操作系统要提供请求调页（或请求调段）功能
[^注3]: 操作系统要提供页面置换（或段置换）的功能

## 2.2 请求分页管理方式

请求分页系统建立在基本分页系统之上，为了支持虚拟存储器功能而增加了请求调页和页面置换功能

### 2.2.1 页表机制

与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置。当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。因此，请求页表项增加了四个字段

![图片.png](https://upload-images.jianshu.io/upload_images/26868451-3a7f87682093ed76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 状态位：是否已调入内存
- 访问字段：可记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考
- 修改位：页面调入内存后是否被修改过
- 外存地址：页面在外存中的存放位置

### 2.2.2 缺页中断机构

在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。

- 缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断
- 一条指令在执行期间，可能产生多次缺页中断。

### 2.2.3 地址变换机构

找到对应页表项后，若对应页面未调入内存，则产生缺页中断，之后由操作系统的缺页中断处理程序进行处理

快表中有的页面一定是在内存中的。若某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面

![图片.png](https://upload-images.jianshu.io/upload_images/26868451-7f76b37017dee619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。
- 和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。
- 需要用某种“页面置换算法”来决定一个换出页面
- 换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/换出太频繁，会有很大的开销。
- 页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。

## 2.3 页面置换算法

页面的换入、换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率

### 2.3.1 最佳置换算法(OPT)

最佳置换算法（OPT，Optimal）：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。

最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。

> 例：假设系统为某进程分配了三个内存块，并考虑到有一下页面号引用串（会依次访问这些页面）：7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1
>
> ![图片.png](https://upload-images.jianshu.io/upload_images/26868451-d6a31b8dfcddaea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>
> 整个过程缺页中断发生了9次，页面置换发生了6次。
>
> 缺页率= 9/20 = 45%

### 2.3.2 先进先出(FIFO)置换算法

先进先出置换算法（FIFO）：每次选择淘汰的页面是最早进入内存的页面。把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。

> 例：假设系统为某进程分配了三个内存块，并考虑到有以下页面号引用串：3, 2, 1, 0, 3, 2, 4, 3, 2, 1, 0, 4
>
> ![图片.png](https://upload-images.jianshu.io/upload_images/26868451-f48dfbddfeae2711.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>
> 分配四个内存块时，缺页次数：10次
>
> 分配三个内存块时，缺页次数：9次

**只有FIFO算法会产生Belady异常[^解释]**。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差

[^解释]: Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。

### 2.3.3 最近最久未使用(LRU)置换算法

最近最久未使用置换算法（LRU，least recently used）：每次淘汰的页面是最近最久未使用的页面。赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。

> 例：假设系统为某进程分配了四个内存块，并考虑到有以下页面号引用串：1, 8, 1, 7, 8, 2, 7, 2, 1, 8, 3, 8, 2, 1, 3, 1, 7, 1, 3, 7
>
> ![图片.png](https://upload-images.jianshu.io/upload_images/26868451-6ee0e60b4be99973.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大

### 2.3.4 时钟(CLOCK)置换算法

时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法（NRU，NotRecently Used）简单的CLOCK算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）

改进型的时钟置换算法：

简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过。

算法规则：将所有可能被置换的页面排成一个循环队列

- 第一轮：从当前位置开始扫描到第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位——第一优先级：最近没访问，且没修改的页面
- 第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。本轮将所有扫描过的帧访问位设为0——第二优先级：最近没访问，但修改过的页面
- 第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位——第三优先级：最近访问过，但没修改的页面
- 第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。——第四优先级：最近访问过，且修改过的页面

由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描

## 2.4 页面分配策略

### 2.4.1 驻留集大小

对于分页式的虚拟内存，在进程准备执行时，不需要也不可能把-一个进程的所有页都读入主存。因此，操作系统必须决定读取多少页，即决定给特定的进程分配几个页框。

- 若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少

- 驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小

分配方式有

- 固定分配:操作系统为每个进程分配一组固定数目的物理块，在进程运行其间不再改变，即大小不变

- 可变分配:先为每个进程分配一定数目的物理块，在进程运行期间，可即，驻留集大小可变

置换方式有

- 局部置换:发生缺页时只能选进程自己的物理块进行置换。

- 全局置换:可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。

根据以上，现代操作系统通常采用三种策略：

- 固定分配局部置换:系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是:很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)
- 可变分配全局置换:刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程;若已无空闲物理块，则可选择一个**未锁定**的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，**只要某进程发生缺页，都将获得新的物理块**，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页的页可能是系统中任何一个进程中的页，因此这个**被选中的进程拥有的物理块会减少，缺页率会增加**。
- 可变分配局部置换:刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理课，直至该进程缺页率趋势适当当程度;反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块

>可变分配全局置换:只要缺页就给分配新物理块
>可变分配局部置换:要根据发生缺页的频率来动态地增加或减少进程的物理块

### 2.4.2 调入页面的时机

预调页策略:根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略**主要用于进程的首次调入**，由程序员指出应该先调入哪些部分。

请求调页策略:进程**在运行期间发现缺页时才将所缺页面调入内存**。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘l/O操作，因此I/O开销较大。

### 2.4.3 从何处调入页面

请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区通常采用连续分配方式，而文件区采用离散分配方式，因此对换区的磁盘I/O速度比文件去的更快

1. 系统拥有足够的对换区空间:页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。
2. 系统缺少足够的对换区空间:凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。
3. UNIX方式:运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。

## 2.5 抖动

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)

## 2.6 工作集

工作集:指在某段时间间隔里，进程实际访问页面的集合。

> 区别驻留集:指请求分页存储管理中给进程分配的内存块的集合。

操作系统会根据“窗口尺寸”来算出工作集。

> ![图片.png](https://upload-images.jianshu.io/upload_images/26868451-c41cbf30787a2bb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。[^如]
**一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。**

> 基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法――选择一个不在工作集中的页面进行淘汰。

[^如]: 窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。
